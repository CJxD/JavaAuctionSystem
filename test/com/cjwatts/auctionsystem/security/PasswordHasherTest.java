package com.cjwatts.auctionsystem.security;

import static org.junit.Assert.*;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.cjwatts.auctionsystem.alert.Alerter;
import com.cjwatts.auctionsystem.entity.Password;
import com.cjwatts.auctionsystem.io.AuctionConsole;
import com.cjwatts.auctionsystem.mock.MockPersistenceHandler;

public class PasswordHasherTest {
	private PasswordHasher ph;
	private MockPersistenceHandler mph;

	@BeforeClass
	public static void setupAlerts() {
		Alerter.setHandler(new AuctionConsole());
	}
	
	@Before
	public void setUp() {
		ph = new PasswordHasher();
		mph = new MockPersistenceHandler();
		ph.setStorage(mph);
	}

	@Test
	public void testPreHash() {
		String id = "DouglasAdams";
		String password = "forty-two";
		// Generated by online SHA-256 generator
		byte[] answer = new BigInteger(
				"63bc2b1f8e8a424b3634c3cd381794d699dc4dab244fcbac8b45459f78e13033",
				16).toByteArray();

		assertTrue("Hash incorrect.",
				Arrays.equals(answer, ph.preHash(id, password)));
	}

	@Test
	public void testPreHashUnicode() {
		String id = "⊂( ﾟ ヮﾟ)⊃";
		String password = "{´◕ ◡ ◕｀}";
		// Generated by online SHA-256 generator
		byte[] answer = new BigInteger(
				"b2e60f88448778cd1e85b71712a5055453440420b24ff7b1cf7ac4fbe67b9c14",
				16).toByteArray();

		assertTrue("Hash incorrect.",
				Arrays.equals(answer, ph.preHash(id, password)));
	}

	@Test
	public void testWritePassword() throws NoSuchAlgorithmException {
		// Write double hashed password to mock persistence handler
		String id = "DouglasAdams";
		byte[] passwordHash = new BigInteger(
				"63bc2b1f8e8a424b3634c3cd381794d699dc4dab244fcbac8b45459f78e13033",
				16).toByteArray();
		ph.writePassword(id, passwordHash);

		// The salt changes every time, so we have to recalculate the hash to
		// double check it
		Password password = (Password) mph.data.get(id);
		byte[] salt = password.getSalt();
		byte[] seed = new byte[passwordHash.length + salt.length];

		// Copy bytes manually from passwordHash into seed
		for (int i = 0; i < passwordHash.length; i++) {
			seed[i] = passwordHash[i];
		}
		// Copy bytes manually from salt into seed
		for (int i = 0; i < salt.length; i++) {
			seed[i + passwordHash.length] = salt[i];
		}

		MessageDigest test = MessageDigest.getInstance("SHA-256");
		test.update(seed);

		assertTrue("Hashes did not match.",
				Arrays.equals(test.digest(), password.getPassword()));
	}

	@Test
	public void testCheckPassword() {
		// Correct password
		String id = "DouglasAdams";
		byte[] passwordHash = new BigInteger(
				"63bc2b1f8e8a424b3634c3cd381794d699dc4dab244fcbac8b45459f78e13033",
				16).toByteArray();
		ph.writePassword(id, passwordHash);

		assertTrue("Incorrect password returned incorrect.",
				ph.checkPassword(id, passwordHash));

		// Incorrect password
		passwordHash = new BigInteger(
				"969d5f57b03812bd9c2c408dcfd13a39809a5cd4d251482aad208d6e5c1d0743",
				16).toByteArray();
		assertFalse("Incorrect password returned correct.",
				ph.checkPassword(id, passwordHash));
	}
}
